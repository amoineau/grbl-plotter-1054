<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="moveMarkerToCenterToolStripMenuItem.Text" xml:space="preserve">
    <value>Définir la position actuelle comme marqueur pos.</value>
  </data>
  <data name="compensateAngleToolStripMenuItem.Text" xml:space="preserve">
    <value>Compenser l'angle et l'échelle</value>
  </data>
  <data name="showOverlayGraphicsToolStripMenuItem.Text" xml:space="preserve">
    <value>Afficher les graphiques de superposition</value>
  </data>
  <data name="camSourceToolStripMenuItem.Text" xml:space="preserve">
    <value>Source vidéo</value>
  </data>
  <data name="camSourceToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>Sélectionnez la source de la caméra.</value>
  </data>
  <data name="setRotationAngleToolStripMenuItem.Text" xml:space="preserve">
    <value>Rotation d'image</value>
  </data>
  <data name="teachRadiusTopToolStripMenuItem.Text" xml:space="preserve">
    <value>Définir le rayon d'apprentissage en haut</value>
  </data>
  <data name="lowerPositionToolStripMenuItem.Text" xml:space="preserve">
    <value>Enseigner Position Basse</value>
  </data>
  <data name="lowerPositionToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>Enseigner la vue caméra</value>
  </data>
  <data name="teachRadiusBottomToolStripMenuItem.Text" xml:space="preserve">
    <value>Définir le rayon d'apprentissage en bas</value>
  </data>
  <data name="teachScalingToolStripMenuItem.Text" xml:space="preserve">
    <value>Enseigner la mise à l'échelle</value>
  </data>
  <data name="teachScalingToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>1) Accueil Traceur
2) déplace la caméra en position haute
3) cliquez dans l'image pour enseigner la distance du rayon supérieur
4) déplacez la caméra en position basse
5) cliquez dans l'image pour enseigner la distance du rayon inférieur</value>
  </data>
  <data name="teachOffsetToolStripMenuItem.Text" xml:space="preserve">
    <value>Enseigner Offset</value>
  </data>
  <data name="teachOffsetToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>1) basculez sur 'Outil coord.' (G54)
2) Zéro X, Y position
3) Marquer la position de l'outil (à X = 0, Y = 0) avec l'outil sur la pièce
4) Déplacer le marqueur sous le centre de la vue de la caméra
5) Enseigner la position réelle en décalage
6) basculez sur 'Cam coord.' (G59) - montre maintenant X = 0, Y = 0</value>
  </data>
  <data name="crossHairsToolStripMenuItem.Text" xml:space="preserve">
    <value>ligne de mire</value>
  </data>
  <data name="colorsToolStripMenuItem.Text" xml:space="preserve">
    <value>Couleurs</value>
  </data>
  <data name="setupToolStripMenuItem.Text" xml:space="preserve">
    <value>Installer</value>
  </data>
  <data name="teachMarkerPositionToolStripMenuItem.Text" xml:space="preserve">
    <value>Set XY = Position du marqueur</value>
  </data>
  <data name="setZeroToolStripMenuItem.Text" xml:space="preserve">
    <value>Définir le décalage du système de coordonnées</value>
  </data>
  <data name="setZeroToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>Définir la coordonnée zéro avec le décalage de la caméra</value>
  </data>
  <data name="btnApplyAngle.Text" xml:space="preserve">
    <value>Appliquer l'angle à GCode</value>
  </data>
  <data name="btnApplyAngle.ToolTip" xml:space="preserve">
    <value>Utilisez le bouton droit de la souris pour mesurer l'angle.
Appuyez sur le bouton pour transformer le G-Code en angle mesuré.</value>
  </data>
  <data name="btnCamCoordTool.ToolTip" xml:space="preserve">
    <value>Déplacer la position actuelle de l'outil sous la caméra</value>
  </data>
  <data name="cBCamCoordMove.ToolTip" xml:space="preserve">
    <value>Appliquer un décalage de la caméra aux graphiques</value>
  </data>
  <data name="lblAngle.ToolTip" xml:space="preserve">
    <value>Angle mesuré</value>
  </data>
  <data name="btnCamCoordCam.ToolTip" xml:space="preserve">
    <value>Déplacer la position actuelle de la caméra sous l'outil</value>
  </data>
  <data name="groupBox1.Text" xml:space="preserve">
    <value>Caméra</value>
  </data>
  <data name="groupBox2.Text" xml:space="preserve">
    <value>Décalage de la caméra / mouvement</value>
  </data>
  <data name="lblCenterPos.Text" xml:space="preserve">
    <value>Aucune forme trouvée</value>
  </data>
  <data name="label1.Text" xml:space="preserve">
    <value>angle</value>
  </data>
  <data name="groupBox3.Text" xml:space="preserve">
    <value>mesure</value>
  </data>
  <data name="cBShapeDetection.Text" xml:space="preserve">
    <value>Reconnaissance de forme</value>
  </data>
  <data name="label2.Text" xml:space="preserve">
    <value>Sélectionner le jeu de filtres</value>
  </data>
  <data name="btnAutoCenter.Text" xml:space="preserve">
    <value>Centre cercle rouge</value>
  </data>
  <data name="groupBox4.Text" xml:space="preserve">
    <value>Alignement automatique</value>
  </data>
  <data name="$this.Text" xml:space="preserve">
    <value>Caméra</value>
  </data>
  <data name="setRotationAngleToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>Faire pivoter l'image vidéo - saisir un angle</value>
  </data>
  <data name="upperPositionToolStripMenuItem.Text" xml:space="preserve">
    <value>Enseigner la position supérieure</value>
  </data>
  <data name="upperPositionToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>Enseigner la vue caméra</value>
  </data>
  <data name="teachToolStripMenuItem.Text" xml:space="preserve">
    <value>Enseigner le décalage de la caméra</value>
  </data>
  <data name="teachToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>1) Zéro X, Y position
2) Marquer la position de l’outil (à X = 0, Y = 0)
3) Déplacez-vous jusqu'à ce que le marqueur se trouve au centre de la vue de la caméra
4) Enseigner la position réelle en décalage</value>
  </data>
  <data name="toolStripTextBox1.ToolTipText" xml:space="preserve">
    <value>Faire pivoter l'image vidéo - saisir un angle</value>
  </data>
  <data name="toolStripTextBox2.ToolTipText" xml:space="preserve">
    <value>en unités GRBL (mm ou inch)</value>
  </data>
  <data name="toolStripTextBox3.ToolTipText" xml:space="preserve">
    <value>en unités GRBL (mm ou inch)</value>
  </data>
  <data name="teachZeroPositionToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>Définissez XY = 0; 0 avec le pointeur de la souris et un clic gauche</value>
  </data>
</root>